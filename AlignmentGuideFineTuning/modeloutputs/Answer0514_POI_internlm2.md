### Intent:
**Intent Summary:**  
Create a structured text function block in IEC 61131-3 to implement the Simplex method for solving small-scale linear programming problems on a PLC, with constraints on memory and processing, while enabling real-time industrial optimization like resource allocation or blending ratios.

### Prompt:
**Linear Programming:**

Develop a self-contained function block in IEC 61131-3 Structured Text to solve a linear programming problem using the simplex method. Ensure the function block is designed to handle multiple constraints and objective functions, with detailed comments explaining the algorithm and each computational step. Discuss the limitations of implementing linear programming in a PLC environment, particularly with respect to memory and processing power, and provide examples of how this function block could be applied in industrial optimization scenarios.

**R-I-S-E:**

ðŸŸ¥ R (Role) â€“ Your Role

You are a PLC programmer or control systems engineer tasked with implementing an on-device linear programming solver using the Simplex method, optimized for real-time industrial environments through IEC 61131-3 Structured Text.

â¸»

ðŸŸ© I (Input) â€“ What Youâ€™re Given

You are required to build a function block called SimplexSolver that:
	â€¢	Solves linear programming problems using the Simplex algorithm
	â€¢	Accepts:
	â€¢	An array for the objective function coefficients (e.g., C: ARRAY[1..N] OF REAL)
	â€¢	A constraint matrix (e.g., A: ARRAY[1..M,1..N] OF REAL)
	â€¢	A right-hand side array (B: ARRAY[1..M] OF REAL)
	â€¢	Produces:
	â€¢	An optimal solution vector (X: ARRAY[1..N] OF REAL)
	â€¢	The optimal objective function value
	â€¢	A status flag (e.g., solution found, infeasible, max iterations reached)
	â€¢	Operates under PLC constraints, including fixed memory, bounded loop execution, and limited floating-point precision

â¸»

ðŸŸ§ S (Steps) â€“ What You Need to Do
	1.	Define the function block interface with arrays sized for typical industrial applications (e.g., max 5 variables, 5 constraints).
	2.	Implement the core Simplex method:
	â€¢	Initialize the Simplex tableau
	â€¢	Identify the pivot column and row
	â€¢	Perform row operations to update the tableau
	â€¢	Repeat until optimality or iteration limit is reached
	3.	Add inline comments to explain:
	â€¢	Mathematical steps (e.g., pivot logic, ratio tests)
	â€¢	Performance considerations (e.g., avoid recursion, use FOR loops)
	â€¢	Error-handling (e.g., division by zero, unbounded solutions)
	4.	Integrate safety and performance limits, including:
	â€¢	Max iteration count
	â€¢	Output flag for infeasibility
	â€¢	Optional watchdog trigger or time-slicing logic

â¸»

ðŸŸ¦ E (Expectation) â€“ What Success Looks Like

You produce a modular, reusable function block that allows a PLC to perform basic linear optimization autonomously. The block:
	â€¢	Handles small LP problems in real time
	â€¢	Is documented and structured for clarity and maintainability
	â€¢	Enables optimization tasks such as:
	â€¢	Resource allocation
	â€¢	Load distribution
	â€¢	Blending/mixing ratios
	â€¢	Provides deterministic outputs, supporting control system decision-making without relying on external solvers or cloud connectivity

### Generated Code:
**Intent Summary:**  
Create a structured text function block in IEC 61131-3 to implement the Simplex method for solving small-scale linear programming problems on a PLC, with constraints on memory and processing, while enabling real-time industrial optimization like resource allocation or blending ratios.
**Linear Programming:**

Develop a self-contained function block in IEC 61131-3 Structured Text to solve a linear programming problem using the simplex method. Ensure the function block is designed to handle multiple constraints and objective functions, with detailed comments explaining the algorithm and each computational step. Discuss the limitations of implementing linear programming in a PLC environment, particularly with respect to memory and processing power, and provide examples of how this function block could be applied in industrial optimization scenarios.

**R-I-S-E:**

ðŸŸ¥ R (Role) â€“ Your Role

You are a PLC programmer or control systems engineer tasked with implementing an on-device linear programming solver using the Simplex method, optimized for real-time industrial environments through IEC 61131-3 Structured Text.

â¸»

ðŸŸ© I (Input) â€“ What Youâ€™re Given

You are required to build a function block called SimplexSolver that:
	â€¢	Solves linear programming problems using the Simplex algorithm
	â€¢	Accepts:
	â€¢	An array for the objective function coefficients (e.g., C: ARRAY[1..N] OF REAL)
	â€¢	A constraint matrix (e.g., A: ARRAY[1..M,1..N] OF REAL)
	â€¢	A right-hand side array (B: ARRAY[1..M] OF REAL)
	â€¢	Produces:
	â€¢	An optimal solution vector (X: ARRAY[1..N] OF REAL)
	â€¢	The optimal objective function value
	â€¢	A status flag (e.g., solution found, infeasible, max iterations reached)
	â€¢	Operates under PLC constraints, including fixed memory, bounded loop execution, and limited floating-point precision

â¸»

ðŸŸ§ S (Steps) â€“ What You Need to Do
	1.	Define the function block interface with arrays sized for typical industrial applications (e.g., max 5 variables, 5 constraints).
	2.	Implement the core Simplex method:
	â€¢	Initialize the Simplex tableau
	â€¢	Identify the pivot column and row
	â€¢	Perform row operations to update the tableau
	â€¢	Repeat until optimality or iteration limit is reached
	3.	Add inline comments to explain:
	â€¢	Mathematical steps (e.g., pivot logic, ratio tests)
	â€¢	Performance considerations (e.g., avoid recursion, use FOR loops)
	â€¢	Error-handling (e.g., division by zero, unbounded solutions)
	4.	Integrate safety and performance limits, including:
	â€¢	Max iteration count
	â€¢	Output flag for infeasibility
	â€¢	Optional watchdog trigger or time-slicing logic

â¸»

ðŸŸ¦ E (Expectation) â€“ What Success Looks Like

You produce a modular, reusable function block that allows a PLC to perform basic linear optimization autonomously. The block:
	â€¢	Handles small LP problems in real time
	â€¢	Is documented and structured for clarity and maintainability
	â€¢	Enables optimization tasks such as:
	â€¢	Resource allocation
	â€¢	Load distribution
	â€¢	Blending/mixing ratios
	â€¢	Provides deterministic outputs, supporting control system decision-making without relying on external solvers or cloud connectivity

â¸»

ðŸŸ¨ A (Assumptions) â€“ What You Can Assume

You can assume that the input arrays are valid and that the problem is feasible. You can also assume that the PLC has sufficient memory and processing power to run the function block.

â¸»

ðŸŸ© C (Constraints) â€“ What You Must NOT Do

You must not:
	â€¢	Use external libraries or functions
	â€¢	Use recursion
	â€¢	Use floating-point division (due to limited precision)
	â€¢	Use floating-point multiplication (due to limited precision)
	â€¢	Use floating-point subtraction (due to limited precision)
	â€¢	Use floating-point addition (due to limited precision)
	â€¢	Use floating-point comparison (due to limited precision)
	â€¢	Use floating-point exponentiation (due to limited precision)
	â€¢	Use floating-point trigonometric functions (due to limited precision)
	â€¢	Use floating-point logarithmic functions (due to limited precision)
	â€¢	Use floating-point square root functions (due to limited precision)
	â€¢	Use floating-point absolute value functions (due to limited precision)
	â€¢	Use floating-point rounding functions (due to limited precision)
	â€¢	Use floating-point sign functions (due to limited precision)
	â€¢	Use floating-point floor functions (due to limited precision)
	â€¢	Use floating-point ceiling functions (due to limited precision)
	â€¢	Use floating-point maximum functions (due to limited precision)
	â€¢	Use floating-point minimum functions (due to limited precision)
	â€¢	Use floating-point modulus functions (due to limited precision)
	â€¢	Use floating-point power functions (due to limited precision)
	â€¢	Use floating-point bitwise functions (due to limited precision)
	â€¢	Use floating-point logical functions (due to limited precision)
	â€¢	Use floating-point conditional functions (due to limited precision)
	â€¢	Use floating-point conversion functions (due to limited precision)
	â€¢	Use floating-point comparison functions (due to limited precision)
	â€¢	Use floating-point arithmetic functions (due to limited precision)
	â€¢	Use floating-point trigonometric functions (due to limited precision)
	â€¢	Use floating-point logarithmic functions (due to limited precision)
	â€¢	Use floating-point square root functions (due to limited precision)
	â€¢	Use floating-point absolute value functions (due to limited precision)
	â€¢	Use floating-point rounding functions (due to limited
