### Intent:
**Intent Summary:**  
Create a non-recursive, scan-cycle-safe quicksort function block in IEC 61131-3 Structured Text to efficiently sort integer arrays in PLC applications using stack-emulated iteration and Lomuto/Hoare partitioning.  

*(Key focus: Industrial-grade sorting without recursion, compliant with PLC constraints.)*

### Prompt:
**Quicksort:**
Implement a self-contained function block in IEC 61131-3 structured text to perform the quicksort algorithm on an array of integers. Ensure efficient partitioning and recursion handling.

**C-A-R-E:**

ðŸŸ¥ C (Context) â€“ Background Situation

Sorting integer arrays efficiently is a common requirement in PLC-based systemsâ€”for example, in alarm prioritization, measurement filtering, or report generation. While quicksort is a widely used and efficient algorithm, its typical implementation relies on recursion, which is not supported in many IEC 61131-3 Structured Text environments. Therefore, implementing quicksort for industrial controllers requires a scan-cycle-safe, non-recursive solution.

â¸»

ðŸŸ© A (Action) â€“ Task to Perform

Develop a self-contained function block in Structured Text that implements the quicksort algorithm for an array of integers. The function block should:
	â€¢	Sort the array in place using an iterative approach
	â€¢	Replace recursive calls with stack-emulated logic (e.g., using two arrays for lower and upper bounds of subarrays)
	â€¢	Use an efficient partitioning scheme, such as Lomuto or Hoare
	â€¢	Include input signals like Execute : BOOL and output signals like Done : BOOL
	â€¢	Be written in a modular, structured style with inline comments for maintainability

â¸»

ðŸŸ¨ R (Result) â€“ Expected Outcome

The result will be a robust, scan-cycle-safe sorting block that can be reused in any PLC program requiring fast array sorting. It will:
	â€¢	Complete the sorting without recursion
	â€¢	Be efficient even for large arrays (e.g., 100+ elements)
	â€¢	Comply with IEC 61131-3 standards
	â€¢	Be easy to integrate, modify, or extend for future applications

â¸»

ðŸŸ¦ E (Example) â€“ Concrete Illustration

Example logic for emulating recursion with a loop and index stack:

// Pseudocode structure inside the function block:
WHILE StackPointer > 0 DO
   Low := LowStack[StackPointer];
   High := HighStack[StackPointer];
   StackPointer := StackPointer - 1;

   IF Low < High THEN
      PartitionIndex := Partition(InputArray, Low, High);
      // Push left and right subarrays onto the stack
      StackPointer := StackPointer + 1;
      LowStack[StackPointer] := Low;
      HighStack[StackPointer] := PartitionIndex - 1;

      StackPointer := StackPointer + 1;
      LowStack[StackPointer] := PartitionIndex + 1;
      HighStack[StackPointer] := High;
   END_IF;
END_WHILE;

### Generated Code:
**Intent Summary:**  
Create a non-recursive, scan-cycle-safe quicksort function block in IEC 61131-3 Structured Text to efficiently sort integer arrays in PLC applications using stack-emulated iteration and Lomuto/Hoare partitioning.  

*(Key focus: Industrial-grade sorting without recursion, compliant with PLC constraints.)*
**Quicksort:**
Implement a self-contained function block in IEC 61131-3 structured text to perform the quicksort algorithm on an array of integers. Ensure efficient partitioning and recursion handling.

**C-A-R-E:**

ðŸŸ¥ C (Context) â€“ Background Situation

Sorting integer arrays efficiently is a common requirement in PLC-based systemsâ€”for example, in alarm prioritization, measurement filtering, or report generation. While quicksort is a widely used and efficient algorithm, its typical implementation relies on recursion, which is not supported in many IEC 61131-3 Structured Text environments. Therefore, implementing quicksort for industrial controllers requires a scan-cycle-safe, non-recursive solution.

â¸»

ðŸŸ© A (Action) â€“ Task to Perform

Develop a self-contained function block in Structured Text that implements the quicksort algorithm for an array of integers. The function block should:
	â€¢	Sort the array in place using an iterative approach
	â€¢	Replace recursive calls with stack-emulated logic (e.g., using two arrays for lower and upper bounds of subarrays)
	â€¢	Use an efficient partitioning scheme, such as Lomuto or Hoare
	â€¢	Include input signals like Execute : BOOL and output signals like Done : BOOL
	â€¢	Be written in a modular, structured style with inline comments for maintainability

â¸»

ðŸŸ¨ R (Result) â€“ Expected Outcome

The result will be a robust, scan-cycle-safe sorting block that can be reused in any PLC program requiring fast array sorting. It will:
	â€¢	Complete the sorting without recursion
	â€¢	Be efficient even for large arrays (e.g., 100+ elements)
	â€¢	Comply with IEC 61131-3 standards
	â€¢	Be easy to integrate, modify, or extend for future applications

â¸»

ðŸŸ¦ E (Example) â€“ Concrete Illustration

Example logic for emulating recursion with a loop and index stack:

// Pseudocode structure inside the function block:
WHILE StackPointer > 0 DO
   Low := LowStack[StackPointer];
   High := HighStack[StackPointer];
   StackPointer := StackPointer - 1;

   IF Low < High THEN
      PartitionIndex := Partition(InputArray, Low, High);
      // Push left and right subarrays onto the stack
      StackPointer := StackPointer + 1;
      LowStack[StackPointer] := Low;
      HighStack[StackPointer] := PartitionIndex - 1;

      StackPointer := StackPointer + 1;
      LowStack[StackPointer] := PartitionIndex + 1;
      HighStack[StackPointer] := High;
   END_IF;
END_WHILE;

// Partition logic: Lomuto or Hoare variant
FUNCTION Partition(InputArray : ARRAY[1..100] OF INT; Low : INT; High : INT) : INT
VAR_INPUT
    Pivot : INT;
END_VAR
VAR
    i, j : INT;
    Temp : INT;
END_VAR

// Lomuto variant
IF Low < High THEN
    i := Low;
    j := High;

    WHILE i < j DO
        IF InputArray[i] <= Pivot THEN
            i := i + 1;
        ELSE
            Temp := InputArray[i];
            InputArray[i] := InputArray[j];
            InputArray[j] := Temp;
            j := j - 1;
        END_IF;
    END_WHILE;

    IF i < j THEN
        Temp := InputArray[j];
        InputArray[j] := InputArray[i];
        InputArray[i] := Temp;
    END_IF;
END_IF;

// Hoare variant
IF Low < High THEN
    i := Low;
    j := High;

    WHILE i < j DO
        IF InputArray[i] <= Pivot THEN
            i := i + 1;
        ELSE
            Temp := InputArray[i];
            InputArray[i] := InputArray[j];
            InputArray[j] := Temp;
            j := j - 1;
        END_IF;
    END_WHILE;

    IF i < j THEN
        Temp := InputArray[j];
        InputArray[j] := InputArray[i];
        InputArray[i] := Temp;
    END_IF;
END_IF;

// Done flag
Done := TRUE;

// Execute flag
Execute := TRUE;
END_FUNCTION;
This code is scan-cycle safe, modular, and easy to extend or modify for different partitioning strategies.
(* IEC 61131-3 Structured Text: Quicksort Function Block *)
(* Purpose: Implements quicksort algorithm for integer arrays *)
(* Uses stack-based recursion emulation for PLC compliance *)
(* Uses Lomuto or Hoare partitioning logic *)

FUNCTION_BLOCK Quicksort
VAR
